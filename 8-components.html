<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Вебкомпоненти І</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./././assets/theme.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="^---" data-separator-vertical="^--">
          <textarea data-template>
            

# Вебкомпоненти

## Введення до компонентного підходу

---

Компонентний підхід у веброзробці — це методологія проєктування та розробки, яка заснована на створенні перевикористовуваних, незалежних блоків коду, відомих як компоненти. Кожен компонент інкапсулює свою структуру, стилі та поведінку, що спрощує управління та підтримку великих вебзастосунків та дозволяє швидше розвивати проєкти з високим рівнем складності та функціональності.

---

### Основні принципи компонентного підходу

Декомпозиція системи на самостійні модулі, їхнє перевикористання та легкість тестування.

--

### Вигоди та переваги компонентного підходу

- **Модульність та перевикористання**: Компоненти можна легко перевикористовувати в різних частинах застосунку або навіть у різних проєктах, що спрощує розробку.
- **Легкість обслуговування**: Якщо потрібно внести зміни, розробники можуть зосередитися на конкретному компоненті, не турбуючись про вплив змін на інші частини системи.
- **Легкість тестування**: Окремі компоненти можна тестувати незалежно, що полегшує виявлення та усунення помилок.
- **Гнучкість у дизайні**: Компоненти можуть бути створені з різноманітним дизайном та функціональністю, забезпечуючи більшу гнучкість у візуальному представленні застосунку.

--

### Практичні приклади компонентів

- **Навігаційне меню**: Виділений компонент, який управляє навігацією застосунком та може бути легко інтегрований на різні сторінки.
- **Форма пошуку**: Самостійний компонент пошукової форми, який можна перевикористовувати у різних частинах застосунку для забезпечення функціональності пошуку.
- **Картка товару**: Компонент, який відображає інформацію про товар, зазвичай включає зображення, опис і кнопку покупки, та може бути перевикористаний у каталозі товарів.

---

## Вебкомпоненти

Вебкомпоненти — це набір технологій, що дозволяють створювати інкапсульовані та перевикористовувані елементи вебінтерфейсу. Вони забезпечують стандартизований спосіб інкапсуляції HTML, CSS та JavaScript, дозволяючи розробникам створювати власні, повністю налаштовувані HTML-теги.

--

### Універсальність та перевикористовуваність

- **Інкапсуляція**: Кожен вебкомпонент є самостійним і містить весь необхідний HTML, CSS та JavaScript. Це забезпечує універсальність та ізоляцію стилів та скриптів.
- **Перевикористання**: Вебкомпоненти можна легко перевикористовувати в різних частинах застосунку або навіть в різних проєктах, забезпечуючи консистентність та швидкість розробки.
- **Налаштовуваність**: Можливість визначати власні теги та атрибути дає розробникам гнучкість у створенні інтерфейсу.

--

### Переваги використання вебкомпонентів

- **Стандартизація**: Вебкомпоненти є частиною стандарту вебплатформи, що забезпечує сумісність та стабільність.
- **Модульність**: Застосунки стають більш модульними та легшими для обслуговування завдяки ізоляції та перевикористанню компонентів.
- **Інтеграція з наявними технологіями**: Вебкомпоненти можна інтегрувати з іншими бібліотеками та фреймворками, зберігаючи при цьому свою самостійність.
- **Ефективне управління залежностями**: Завдяки інкапсуляції, вебкомпоненти можуть управляти своїми залежностями, зменшуючи конфлікти та спрощуючи управління проєктом.

--

## Приклади використання вебкомпонентів

- **Користувацькі елементи форм**: Створення налаштованих кнопок, слайдерів, перемикачів та інших елементів форми, що мають унікальний вигляд та поведінку.
- **Інтерактивні віджети**: Розробка віджетів, таких як календарі, чати або графіки, які можна легко інтегрувати в будь-який застосунок.
- **Шаблони сторінок**: Створення шаблонів сторінок або секцій, які можна перевикористовувати в різних проєктах із збереженням консистентності стилів та функціональності.

---

## Огляд специфікації вебкомпонентів

Глибокий огляд основних компонентів специфікації вебкомпонентів: шаблони HTML, Custom Elements та Shadow DOM.

---

## Шаблони HTML

Механізм, що дозволяє веброзробникам створювати фрагменти маркування, які не відображаються на сторінці до того моменту, поки їх не буде активовано за допомогою JavaScript. Це забезпечує ефективне перевикористання коду та легкість управління структурою застосунку.

```html
<template id="my-template">
  <p>Це приклад шаблону.</p>
</template>
```

--

### Призначення HTML Template

- **Перевикористання коду**: Створення загальних шаблонів для часто використовуваних фрагментів інтерфейсу.
- **Організація**: Структурування HTML-коду для більшої чіткості та зрозумілості.
- **Ефективність**: Зниження затрат на ресурси, оскільки шаблони не обробляються браузером до їх активації.

---

## Custom Elements — створення власних HTML-елементів

**Custom Elements** дозволяють розробникам створювати свої власні HTML-елементи, визначати їх поведінку та властивості. Це робить інтерфейси більш інтерактивними та модульними.

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
    // визначення поведінки елемента
  }
}
customElements.define("my-element", MyElement);
```

--

### Особливості Custom Elements

- **Розширення функціональності**: Визначення нових елементів з унікальними властивостями та методами.
- **Відновлення**: Можливість наслідування властивостей від наявних HTML-елементів.
- **Інкапсуляція**: Захист компонентів від впливу зовнішніх стилів та скриптів.

---

## Shadow DOM для енкапсуляції та ізоляції компонентів

**Shadow DOM** вводить концепцію інкапсульованих «тіньових» дерев DOM для HTML-елементів. Він дозволяє ізолювати стилі та маркування компонента від решти документу, запобігаючи несподіваним конфліктам та перекриттям.

```javascript
const shadowHost = document.getElementById("shadow-host");
const shadowRoot = shadowHost.attachShadow({ mode: "open" });
shadowRoot.innerHTML =
  "<style>p { color: red; }</style><p>Це тіньовий DOM!</p>";
```

--

### Переваги Shadow DOM

- **Стилізаційна ізоляція**: Стилі в тіньовому DOM не впливають на основний документ і навпаки.
- **Структурна ізоляція**: Компоненти можуть мати свою власну структуру DOM, незалежну від основного документу.
- **Енкапсуляція**: Допомагає уникнути конфліктів імен та забезпечує чистоту коду.

--

## Практичне використання вебкомпонентів

--

### Інтеграція з існуючими фреймворками та бібліотеками

- **React, Angular, Vue**: Вебкомпоненти можуть бути інтегровані з цими популярними фронтенд фреймворками, забезпечуючи легкість використання та широку сумісність.
- **Polymer та LitElement**: Бібліотеки, які полегшують створення та управління вебкомпонентами, надаючи додаткові утиліти та шаблони.

--

### Типові шаблони та кращі практики

- **Енкапсуляція та ізоляція**: Використання Shadow DOM для забезпечення ізоляції стилів та скриптів, що дозволяє уникнути конфліктів та зберегти незалежність компонентів.
- **Перевикористання та композиція**: Створення невеликих, фокусованих компонентів, які можуть бути легко скомбіновані для створення більш складних інтерфейсів.
- **Доступність та семантика**: Забезпечення, що кастомні елементи підтримують стандарти доступності, зокрема, за допомогою ARIA ролей та атрибутів.

--

## Практичні приклади

- **Застосунки електронної комерції**: Кастомні компоненти для продуктових карток, оглядів корзини та процесів оформлення замовлення.
- **Портфоліо та особисті вебсайти**: Унікальні галереї, слайдери та інтерактивні біографічні секції.
- **Застосунки для управління завданнями**: Інтерактивні списки завдань, панелі управління та нагадування.

---

## Компонент «Пошук»

### Приклад імплементації

--

### Template

```html
<template id="search-template">
  <div class="search-wrapper">
    <input type="text" placeholder="Введіть пошуковий запит..." />
    <button>Пошук</button>
  </div>

  <style>
    /* ... */
  </style>
</template>
```

--

## Custom Element

```js
// search-component.js
class SearchComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    const template = document.getElementById("search-template").content;
    this.shadowRoot.appendChild(template.cloneNode(true));
  }

  // Викликається коли компонент доданий у DOM
  connectedCallback() {
    const button = this.shadowRoot.querySelector("button");
    button.addEventListener("click", this.onSearch.bind(this));
  }

  // Викликається коли компонент видалений із DOM
  disconnectedCallback() {
    const button = this.shadowRoot.querySelector("button");
    button.removeEventListener("click", this.onSearch.bind(this));
  }

  // Функція для обробки натискання на кнопку пошуку
  onSearch() {
    const input = this.shadowRoot.querySelector("input");
    console.log(`Пошуковий запит: ${input.value}`);
    // Тут може бути логіка для виконання пошуку
  }
}

// Реєстрація нового елемента
customElements.define("search-component", SearchComponent);
```

--

### Використання в документі

```html
<script src="search-component.js"></script>
...

<body>
  <header>
    <search-component></search-component>
  </header>
</body>
```

---

## Важливість компонентного підходу в розробці

Компонентний підхід грає критичну роль в сучасній веброзробці. Він дозволяє розробникам створювати ефективні, стійкі та легко підтримувані застосунки. Інкапсуляція та перевикористання коду покращують продуктивність робочого процесу, спрощують тестування та забезпечують консистентність інтерфейсу користувача.

--

### Загальні переваги використання вебкомпонентів

- **Ізоляція та інкапсуляція**: Вебкомпоненти забезпечують чітку ізоляцію стилів та поведінки, знижуючи ризик конфліктів у коді.
- **Перевикористання та модульність**: Вебкомпоненти можна легко перевикористовувати в різних частинах застосунку або навіть між проєктами.
- **Сумісність та стандартизація**: Вони є частиною стандарту вебплатформи, що забезпечує широку сумісність з різними інструментами та браузерами.
- **Легкість інтеграції**: Можуть легко інтегруватися з сучасними фреймворками та бібліотеками, зберігаючи при цьому їх незалежність.

--

Компонентний підхід та вебкомпоненти суттєво змінюють спосіб розробки вебзастосунків, забезпечуючи більшу гнучкість, ефективність та масштабованість. Розширення знань та навичок у цій галузі відкриває нові можливості для створення інноваційних та високоякісних вебрішень.

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"_":["./"],"css":"./assets/theme.css","static":"public","static-dirs":"assets","staticDirs":"assets","assets-dir":".","assetsDir":"."}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
