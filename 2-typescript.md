---
title: "Typescript II"
customTheme: "theme"
width: 1280
height: 720
---

# Typescript

## Інтерфейси та класи. Складні типи

---

## Інтерфейси

Інтерфейс у TypeScript — це структура, що визначає форму об'єкта. Він описує, які властивості та методи повинен мати об'єкт, але не визначає їх реалізацію. Інтерфейси часто використовуються для опису форми об'єктів, які передаються як аргументи функцій або повертаються з них, а також для опису форми класів.

--

## Визначення форми об'єкта

Інтерфейс описує, які властивості, методи та індексні типи повинен мати об'єкт. Це включає імена властивостей, типи даних, які вони приймають, та типи даних, які вони повертають.

```ts
// Визначення інтерфейсу
interface Person {
  // Властивості
  name: string;
  // Метод
  greet(phrase: string): void;
  // Індексний тип
  [propName: string]: any;
}

// Створення об'єкта, який відповідає інтерфейсу Person
const john: Person = {
  name: "John Doe",
  greet(phrase: string) {
    console.log(`${phrase} ${this.name}`);
  },
  // Додаткова властивість завдяки індексному типу
  hobbies: ["reading", "gaming"],
};

// Використання методу об'єкта
john.greet("Hello, my name is"); // Виводить: Hello, my name is John Doe

// Вивід додаткової властивості
console.log(john.hobbies); // Виводить: ['reading', 'gaming']
```

--

### Необов'язкові властивості

Інтерфейси можуть мати необов'язкові властивості, позначені знаком `?`. Це означає, що об'єкти, які імплементують цей інтерфейс, можуть або не мати ці властивості.

```ts
interface Employee {
  id: number; // Обов'язкова властивість
  name: string; // Обов'язкова властивість
  email?: string; // Необов'язкова властивість
  phoneNumber?: string; // Необов'язкова властивість
}

const manager: Employee = {
  id: 1,
  name: "Alice",
  email: "alice@example.com", // phoneNumber не вказано, і це нормально
};
```

--

### Розширення інтерфейсів

Інтерфейс може наслідувати один або кілька інших інтерфейсів, використовуючи ключове слово extends. Це дозволяє комбінувати інтерфейси і створювати складніші структури.

```ts
// Базовий інтерфейс для особистої інформації
interface PersonalInfo {
  name: string;
  age: number;
}

// Інтерфейс для контактної інформації
interface ContactInfo {
  email: string;
  phoneNumber: string;
}

// Інтерфейс, що розширює обидва попередніх інтерфейси
interface Employee extends PersonalInfo, ContactInfo {
  position: string;
  department: string;
}

// Створення об'єкта, який відповідає розширеному інтерфейсу Employee
const employee: Employee = {
  name: "John Doe",
  age: 28,
  email: "johndoe@example.com",
  phoneNumber: "123-456-7890",
  position: "Software Engineer",
  department: "Development",
};
```

---

## Класи як шаблони об'єктів

Класи в TypeScript надають засоби для створення об'єктів з визначеною структурою та поведінкою, об'єднуючи дані та методи.

--

### Визначення та створення класів

#### Визначення класу

Клас визначається за допомогою ключового слова `class`, за яким слідує ім'я класу. Всередині фігурних дужок розміщуються властивості та методи класу.

#### Конструктор

Клас може мати спеціальний метод під назвою `constructor`, який викликається при створенні нового екземпляра класу. Конструктор часто використовується для ініціалізації властивостей об'єкта.

#### Створення об'єктів

Нові об'єкти на основі класу створюються за допомогою оператора `new` та виклику конструктора.

--

### Визначення та створення класів

```ts
// Визначення класу
class Animal {
  // Властивості
  name: string;
  // Конструктор
  constructor(name: string) {
    this.name = name;
  }
  // Метод
  doSomething() {
    /* ... */
  }
}

const dog = new Animal("DOG");
```

--

### Властивості та Методи:

#### Властивості

Ви можете визначити властивості класу, які будуть характеристиками кожного об'єкта, створеного з цього класу.

#### Методи

Методи класу — це функції, що визначають поведінку об'єктів цього класу.

--

### Модифікатори доступу

#### Public

Члени класу є публічними за замовчуванням і можуть бути доступні з будь-якого місця.

#### Private

Приватні члени класу можуть бути доступні тільки всередині класу, що їх визначив.

#### Protected

Захищені члени схожі на приватні, але вони також доступні в класах-нащадках.

--

### Public

```ts
class Animal {
  public name: string;

  constructor(name: string) {
    this.name = name;
  }

  public describe(): void {
    console.log(`This is an animal named ${this.name}.`);
  }
}

const cat = new Animal("Whiskers");
cat.describe(); // Працює: "This is an animal named Whiskers."
console.log(cat.name); // Працює: "Whiskers"
```

--

### Private

```ts
class Animal {
  private age: number;

  constructor(age: number) {
    this.age = age;
  }

  getAge(): number {
    return this.age;
  }
}

const dog = new Animal(5);
console.log(dog.getAge()); // Працює: 5
console.log(dog.age); // Помилка: 'age' is private and only accessible within class 'Animal'.
```

--

### Protected

```ts
class Animal {
  protected type: string;
  constructor(type: string) {
    this.type = type;
  }
}

class Bird extends Animal {
  displayType(): void {
    console.log(this.type);
  }
}

const sparrow = new Bird("Sparrow");
sparrow.displayType(); // Працює: "Sparrow"
// Помилка: 'type' is protected and only accessible within class 'Animal' and its subclasses.
console.log(sparrow.type);
```

---

## Mapped Types

Mapped types дозволяють створювати нові типи на основі старих типів, шляхом перебору їх властивостей та застосування певних операцій до типів цих властивостей. Вони корисні, коли вам потрібно трансформувати один тип в інший, змінюючи, наприклад, усі властивості на необов'язкові або тільки для читання.

--

### Основні можливості

#### Трансформація існуючих типів

За допомогою mapped types ви можете взяти існуючий тип і змінити його властивості (наприклад, зробити всі властивості необов'язковими або тільки для читання).

#### Динамічне створення типів

Mapped types дозволяють динамічно створювати нові типи на основі старих, що робить ваш код більш адаптивним і здатним до масштабування.

#### Контроль за властивостями

Ви можете точно контролювати, які властивості повинні бути змінені, а які ні, що надає вам додатковий рівень деталізації та контролю.

--

### Приклад

```ts
type Point = {
  x: number;
  y: number;
};

// Зробити всі властивості типу Point тільки для читання
type ReadonlyPoint = { readonly [K in keyof Point]: Point[K] };

const point: ReadonlyPoint = { x: 10, y: 20 };
// point.x = 5; // Помилка: Cannot assign to 'x' because it is a read-only property.
```

---

## Умовні типи

Умовні типи в TypeScript дозволяють вибирати між двома типами в залежності від того, чи виконується певна умова. Вони визначаються за допомогою тернарного оператора extends ? TrueType : FalseType, де extends використовується для визначення умови.

--

### Основні можливості

#### Динамічний вибір типу

Умовні типи дозволяють динамічно вибирати тип на основі умови, що робить типізацію більш гнучкою.

#### Типи на основі умов

Можна визначати типи, які змінюються в залежності від умов, таких як типи параметрів або типи повернення.

#### Узагальнення та вдосконалення типів

Умовні типи можна використовувати для узагальнення типів у загальних випадках або для їх вдосконалення у більш конкретних сценаріях.

--

### Приклад

```ts
// Умовний тип, який визначає, чи є тип T числовим літералом
type NumericOrString<T> = T extends number ? number : string;

// Функція, яка приймає параметр будь-якого типу T
// і повертає number або string на основі умовного типу NumericOrString
function processValue<T>(value: T): NumericOrString<T> {
  if (typeof value === "number") {
    return value * 2; // Якщо 'number', подвоїти значення
  } else {
    return `Value is: ${value}`; // Якщо не 'number', повернути рядок
  }
}

// Використання функції
const result1 = processValue(10); // Тип result1 виведений як number
const result2 = processValue("hello"); // Тип result2 виведений як string

console.log(result1); // Виводить: 20
console.log(result2); // Виводить: "Value is: hello"
```

---

## Дженерики (Generic Types)

Шаблони типів, які дозволяють створювати компоненти (наприклад, функції, інтерфейси або класи), які можуть працювати з будь-яким типом даних. Вони допомагають зробити код більш гнучким, дозволяючи йому працювати з різними типами, зберігаючи при цьому строгість і безпеку типів.

--

### Створення функцій, які працюють з різними типами

Замість написання декількох функцій для кожного типу, ви можете створити одну універсальну функцію, яка працюватиме з будь-яким типом.

```ts
// Оголошення функції з дженериком
function getFirstElement<T>(array: T[]): T {
  return array[0];
}

// Використання функції з різними типами
const firstNumber = getFirstElement([1, 2, 3]); // тип number
const firstString = getFirstElement(["apple", "banana"]); // тип string
```

--

### Створення компонентів, які можуть бути повторно використані з різними типами

Наприклад, якщо ви створюєте клас для стеку або черги, ви можете використовувати дженерики, щоб ваш клас міг зберігати елементи будь-якого типу.

```ts
// Оголошення класу з дженериком
class Box<T> {
  content: T;
  constructor(value: T) {
    this.content = value;
  }
}

// Створення екземплярів класу з різними типами
const numberBox = new Box(10); // зберігає число
const stringBox = new Box("Hello World"); // зберігає рядок
```

---

## Модулі

Модулі в TypeScript є ключовим інструментом для організації та структурування коду, особливо коли йдеться про розробку та підтримку великих проєктів. Вони дозволяють розділити код на менші, логічно відокремлені частини, що спрощує розуміння, тестування та управління кодом.

--

### Основні особливості модулів

#### Ізоляція коду

Кожен модуль має свою власну область видимості. Змінні, функції, класи, оголошені в модулі, не доступні ззовні, поки вони явно не експортуються.

#### Експорт та Імпорт

Модулі дозволяють експортувати частини коду (наприклад, змінні, функції, класи, інтерфейси), які потім можуть бути імпортовані в інших модулях. Це забезпечує чітке визначення того, які частини модуля доступні для використання ззовні.

#### Керування залежностями

Завдяки імпорту та експорту, модулі дозволяють явно визначити, які саме частини інших модулів використовуються, що полегшує управління залежностями у проєкті.

--

### Приклад

```ts
// mathUtils.ts
export function add(x: number, y: number): number {
  return x + y;
}

// app.ts
import { add, subtract } from "./mathUtils";

const sum = add(10, 5);

console.log(`Sum: ${sum}`);
```

---

## Namespaces

Простори імен (namespaces) у TypeScript — це спосіб групування пов'язаних функцій, інтерфейсів, класів та інших конструкцій під одним ім'ям. Вони дуже корисні у великих програмах для уникнення конфліктів імен і забезпечення організованості коду.

--

### Основні особливості просторів імен

#### Ізоляція коду

Простори імен дозволяють ізолювати групу пов'язаних елементів (класів, інтерфейсів, функцій тощо) від інших частин програми.

#### Уникнення конфліктів імен

У великих програмах, де використовується багато зовнішніх бібліотек і модулів, простори імен допомагають уникнути конфліктів шляхом об'єднання функціональності під унікальним ім'ям.

#### Організація коду

Простори імен дозволяють структурувати код більш логічно, об'єднуючи пов'язані частини разом.

--

### Приклад

```ts
namespace MathOperations {
  export function add(x: number, y: number): number {
    return x + y;
  }
  export function subtract(x: number, y: number): number {
    return x - y;
  }
}

const sum = MathOperations.add(10, 5);
const difference = MathOperations.subtract(10, 5);

console.log(`Sum: ${sum}, Difference: ${difference}`);
```
